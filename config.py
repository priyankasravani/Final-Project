import sys,os,random,pprint,time,pickle,math,cv2,copy
from matplotlib import pyplot as plt
from optparse import OptionParser
import tensorflow as tf
import pandas as pd
import numpy as np


from sklearn.metrics import average_precision_score     #FOR EVALUATING THE MODEL

from keras import backend as K
from keras.utils import layer_utils
from keras.utils.data_utils import get_file
from keras.optimizers import Adam, SGD, RMSprop
from keras.engine.topology import get_source_inputs
from keras.objectives import categorical_crossentropy                                 #Final layer
from keras.layers import Flatten, Dense, Input, Conv2D, MaxPooling2D, Dropout         #CNN layers 1
from keras.layers import GlobalAveragePooling2D, GlobalMaxPooling2D, TimeDistributed  #CNN layers 1

from keras.models import Model
from keras.utils import generic_utils
from keras.engine import Layer, InputSpec
from keras import initializers, regularizers



class Configuration:

	def __init__(self):
		# Set True if you want to see the progress updates
		self.verbose = True

		# Set True for data augmentation
		self.use_horizontal_flips = True
		self.use_vertical_flips = True
		self.rot_90 = True

		# Anchor box scales. In order to choose the set of anchors we usually define a set of sizes (e.g. 64px, 128px, 256px).Original anchor_box_scales in the paper is [128, 256, 512] 
        # If size of the image is smaller, anchor_box_scales should be scaled accordingly
		self.anchor_box_scales = [128, 256, 512] 

		# Anchor box ratios, a set of ratios between width and height of boxes (e.g. 0.5, 1, 1.5) and use all the possible combinations of sizes and ratios.
		self.anchor_box_ratios = [[1, 1], [0.75, 1.5], [1.5, 0.75]]

		# Size to resize the smallest side of the image. Original setting in paper is 600. Smaller will save training time
		self.im_size = 256

		# image channel-wise mean to subtract
		self.img_channel_mean = [103.939, 116.779, 123.68]         
		self.img_scaling_factor = 1.0

		# number of ROIs at once
		self.num_rois = 4

		# stride at the RPN (this depends on the network configuration)
		self.rpn_stride = 16

		self.balanced_classes = False

		# scaling the stdev
		self.std_scaling = 4.0
		self.classifier_regr_std = [8.0, 8.0, 4.0, 4.0]

		# overlaps for RPN
		self.rpn_min_overlap = 0.3
		self.rpn_max_overlap = 0.7

		# overlaps for classifier ROIs
		self.classifier_min_overlap = 0.1
		self.classifier_max_overlap = 0.5

        # Just Name the base network, we chose vgg
		self.network = 'vgg'

		# placeholder for the class mapping, automatically generated by the parser
		self.class_mapping = None
		self.model_path = None
        